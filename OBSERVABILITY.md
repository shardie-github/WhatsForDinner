# Observability Guide

This guide covers the observability infrastructure for What's For Dinner, including logging, tracing, and metrics.

## Overview

The observability system provides:
- **Structured Logging** with correlation IDs and PII redaction
- **Distributed Tracing** with OpenTelemetry
- **Custom Metrics** for business and technical KPIs
- **Health Monitoring** and alerting

## Quick Start

### 1. Initialize Observability

```typescript
import { initializeObservability } from '@/observability';

// Initialize in your app startup
initializeObservability();
```

### 2. Basic Logging

```typescript
import { logger } from '@/observability';

// Basic logging
logger.info('User logged in', { userId: '123' });
logger.error('Database connection failed', error, { operation: 'connect' });

// Create child logger with context
const userLogger = logger.child({ userId: '123', sessionId: 'abc' });
userLogger.info('User action completed');
```

### 3. Tracing

```typescript
import { withSpan, withDatabaseSpan } from '@/observability';

// Wrap functions with spans
const result = await withSpan('user.login', async (span) => {
  span.setAttributes({ userId: '123' });
  return await loginUser(credentials);
});

// Database operations
const user = await withDatabaseSpan('SELECT', 'users', async (span) => {
  return await db.query('SELECT * FROM users WHERE id = ?', [userId]);
});
```

### 4. Metrics

```typescript
import { record } from '@/observability';

// Record business metrics
record.mealGenerated(userId, duration);
record.userRegistered(userId);
record.paymentProcessed(userId, amount, 'USD');

// Record API metrics
record.apiRequest('POST', '/api/meals', 200, duration);
```

## Logging

### Structured Logging

All logs are structured JSON with:
- Timestamp
- Log level
- Message
- Context (with PII redaction)
- Error details (if applicable)

### Log Levels

- `debug` - Detailed debugging information
- `info` - General information
- `warn` - Warning conditions
- `error` - Error conditions
- `fatal` - Fatal conditions

### PII Redaction

Automatically redacts sensitive fields:
- passwords, tokens, secrets, keys
- emails, phones, SSNs
- credit cards, CVVs, PINs
- authorization headers, cookies

### Correlation IDs

Every request gets a unique correlation ID for tracking across services:

```typescript
// Request logger middleware
app.use(requestLogger);

// Access logger in route handlers
app.get('/api/users', (req, res) => {
  req.logger.info('Fetching users');
  // Correlation ID automatically included
});
```

## Tracing

### OpenTelemetry Integration

Uses OpenTelemetry for distributed tracing with:
- Automatic instrumentation for HTTP, database, and other operations
- Custom spans for business logic
- Trace context propagation
- Span attributes and events

### Span Types

#### Database Spans
```typescript
await withDatabaseSpan('SELECT', 'users', async (span) => {
  span.setAttributes({
    'db.query': 'SELECT * FROM users WHERE active = true',
    'db.rows_affected': 42,
  });
  return await db.query(sql);
});
```

#### HTTP Spans
```typescript
await withHttpSpan('POST', '/api/meals', async (span) => {
  span.setAttributes({
    'http.status_code': 201,
    'http.response_size': 1024,
  });
  return await fetch('/api/meals', options);
});
```

#### Business Spans
```typescript
await withBusinessSpan('meal_generation', async (span) => {
  span.setAttributes({
    'business.user_id': userId,
    'business.meal_type': 'dinner',
    'business.dietary_restrictions': ['vegetarian'],
  });
  return await generateMeal(userId, preferences);
});
```

#### AI Spans
```typescript
await withAISpan('text_generation', 'gpt-4', async (span) => {
  span.setAttributes({
    'ai.tokens_used': 150,
    'ai.model_version': '4.0',
  });
  return await openai.chat.completions.create(options);
});
```

### Span Attributes

Add attributes to current span:
```typescript
import { addSpanAttributes, addSpanEvent } from '@/observability';

addSpanAttributes({
  'user.id': userId,
  'operation.type': 'meal_generation',
});

addSpanEvent('meal_generated', {
  'meal.id': mealId,
  'meal.difficulty': 'medium',
});
```

## Metrics

### Counter Metrics

Track total counts:
- `api_requests_total` - API requests by method/endpoint/status
- `meals_generated_total` - Meals generated by user
- `users_registered_total` - User registrations
- `payments_processed_total` - Payments by user/currency
- `db_queries_total` - Database queries by operation/table
- `ai_requests_total` - AI requests by model/operation

### Histogram Metrics

Track distributions:
- `api_duration_seconds` - API response times
- `db_duration_seconds` - Database query times
- `ai_duration_seconds` - AI request times
- `meal_generation_duration_seconds` - Meal generation times

### Gauge Metrics

Track current values:
- `active_users` - Current active users
- `memory_usage_bytes` - Memory usage
- `cpu_usage_percent` - CPU usage
- `meals_in_queue` - Meals in generation queue
- `pending_payments` - Pending payments

### Recording Metrics

```typescript
import { record } from '@/observability';

// API metrics
record.apiRequest('POST', '/api/meals', 201, 150);

// Database metrics
record.dbQuery('SELECT', 'users', 25, false);

// AI metrics
record.aiRequest('gpt-4', 'text_generation', 2000, false);

// Business metrics
record.mealGenerated(userId, 5000);
record.userRegistered(userId);
record.paymentProcessed(userId, 29.99, 'USD');

// System metrics
record.setActiveUsers(150);
record.setMemoryUsage(1024 * 1024 * 512); // 512MB
record.setCpuUsage(45.2);
```

### Decorators

Use decorators for automatic metric recording:

```typescript
import { recordMetric, recordPerformance } from '@/observability';

class MealService {
  @recordMetric('meals_generated_total')
  @recordPerformance('meal_generation_duration_seconds')
  async generateMeal(userId: string, preferences: MealPreferences) {
    // Implementation
  }
}
```

## Grafana Integration

### OTLP Endpoint

Configure your Grafana instance to receive OTLP data:

```yaml
# docker-compose.yml
services:
  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    environment:
      - GF_FEATURE_TOGGLES_ENABLE=otlp
```

### Dashboard Queries

#### API Performance
```promql
# Request rate
rate(api_requests_total[5m])

# Error rate
rate(api_errors_total[5m]) / rate(api_requests_total[5m])

# P95 latency
histogram_quantile(0.95, rate(api_duration_seconds_bucket[5m]))
```

#### Business Metrics
```promql
# Meal generation rate
rate(meals_generated_total[1h])

# User registration rate
rate(users_registered_total[1h])

# Payment success rate
rate(payments_processed_total[1h])
```

#### System Health
```promql
# Active users
active_users

# Memory usage
memory_usage_bytes / 1024 / 1024  # MB

# CPU usage
cpu_usage_percent
```

## Alerting

### Critical Alerts

- **High Error Rate**: API error rate > 5%
- **High Latency**: P95 API latency > 2s
- **Database Issues**: DB error rate > 1%
- **Memory Usage**: Memory usage > 80%
- **Payment Failures**: Payment error rate > 2%

### Warning Alerts

- **Queue Backlog**: Meals in queue > 100
- **Low Throughput**: API requests < 10/min
- **High AI Latency**: AI requests > 10s

## Development

### Local Development

```bash
# Start with observability
npm run dev

# View logs
npm run obs:logs

# View metrics
npm run obs:metrics

# View traces
npm run obs:traces
```

### Testing

```typescript
import { logger, record } from '@/observability';

// Test logging
logger.info('Test message', { test: true });

// Test metrics
record.apiRequest('GET', '/test', 200, 100);
```

## Production Considerations

### Log Retention
- Structured logs stored in centralized logging system
- 30-day retention for info/warn logs
- 90-day retention for error/fatal logs

### Trace Sampling
- 100% sampling in development
- 10% sampling in production
- 100% sampling for errors

### Metric Cardinality
- Limit label cardinality to prevent metric explosion
- Use consistent label naming
- Avoid high-cardinality labels (user IDs, etc.)

## Troubleshooting

### Common Issues

1. **Missing Correlation IDs**
   - Ensure request logger middleware is applied
   - Check that logger is properly initialized

2. **High Metric Cardinality**
   - Review label usage
   - Consider aggregation strategies

3. **Trace Sampling Issues**
   - Check sampling configuration
   - Verify trace context propagation

### Debug Commands

```bash
# Check observability health
curl http://localhost:3000/api/health/observability

# View recent logs
tail -f logs/app.log | jq

# Check metrics
curl http://localhost:3000/api/metrics
```

## Best Practices

1. **Logging**
   - Use structured logging consistently
   - Include relevant context
   - Avoid logging sensitive data
   - Use appropriate log levels

2. **Tracing**
   - Create spans for business operations
   - Add meaningful attributes
   - Keep span names consistent
   - Don't create too many spans

3. **Metrics**
   - Use counters for rates
   - Use histograms for distributions
   - Use gauges for current values
   - Keep label cardinality low

4. **Performance**
   - Async logging to avoid blocking
   - Batch metric updates when possible
   - Use sampling for high-volume traces
   - Monitor observability overhead

This observability system provides comprehensive visibility into your application's behavior and performance.